#!/usr/bin/env python3
"""
BTCPay Invoice Payment Script

This script pays BTCPay Server invoices using Bitcoin addresses generated by generate_addresses.py.
It loads generated addresses and invoices, then automatically pays the invoices using the Bitcoin
from the generated addresses.

Requirements:
- bitcoinlib
- requests
- Generated addresses file from generate_addresses.py
- Generated invoices file from generate_invoices.py

Usage:
    python pay_invoices.py --addresses addresses.json --invoices invoices.json
    python pay_invoices.py --config payment_config.json
"""

import argparse
import json
import logging
import time
import random
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from decimal import Decimal

import requests
from tqdm import tqdm

try:
    from bitcoinlib.wallets import Wallet
    from bitcoinlib.keys import HDKey
    from bitcoinlib.transactions import Transaction
    from bitcoinlib.services.services import Service
except ImportError:
    print("Error: bitcoinlib not installed. Install with: pip install bitcoinlib")
    exit(1)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('invoice_payment.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class BTCPayInvoicePayment:
    """BTCPay Server invoice payment processor using generated Bitcoin addresses."""
    
    def __init__(self, network='testnet'):
        """
        Initialize the invoice payment processor.
        
        Args:
            network (str): Network type ('bitcoin' for mainnet, 'testnet' for testnet)
        """
        self.network = network
        self.addresses = []
        self.invoices = []
        self.payment_results = []
        self.failed_payments = []
        
        # Statistics tracking
        self.stats = {
            'total_invoices': 0,
            'successful_payments': 0,
            'failed_payments': 0,
            'total_amount_btc': 0.0,
            'start_time': None,
            'end_time': None
        }
        
        logger.info(f"Initialized BTCPayInvoicePayment for {self.network}")
    
    def load_addresses(self, addresses_file: str) -> bool:
        """
        Load generated addresses from JSON file.
        
        Args:
            addresses_file (str): Path to generated addresses file
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            with open(addresses_file, 'r') as f:
                self.addresses = json.load(f)
            
            logger.info(f"Loaded {len(self.addresses)} addresses from {addresses_file}")
            
            # Validate address format
            if self.addresses and isinstance(self.addresses[0], dict):
                required_fields = ['address', 'private_key', 'network']
                first_addr = self.addresses[0]
                missing_fields = [field for field in required_fields if field not in first_addr]
                if missing_fields:
                    logger.error(f"Address file missing required fields: {missing_fields}")
                    return False
            
            return True
            
        except FileNotFoundError:
            logger.error(f"Address file not found: {addresses_file}")
            return False
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in address file: {str(e)}")
            return False
        except Exception as e:
            logger.error(f"Error loading addresses: {str(e)}")
            return False
    
    def load_invoices(self, invoices_file: str) -> bool:
        """
        Load generated invoices from JSON file.
        
        Args:
            invoices_file (str): Path to generated invoices file (supports wildcards)
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Handle wildcard patterns
            if '*' in invoices_file:
                import glob
                matching_files = glob.glob(invoices_file)
                if not matching_files:
                    logger.error(f"No files found matching pattern: {invoices_file}")
                    return False
                
                # Use the most recent file if multiple matches
                invoices_file = max(matching_files, key=lambda f: Path(f).stat().st_mtime)
                logger.info(f"Using most recent file: {invoices_file}")
            
            with open(invoices_file, 'r') as f:
                data = json.load(f)
            
            # Handle different invoice file formats
            if isinstance(data, dict):
                if 'invoices' in data:
                    self.invoices = data['invoices']
                elif 'generated_invoices' in data:
                    self.invoices = data['generated_invoices']
                else:
                    logger.error("Invalid invoice file format: missing 'invoices' or 'generated_invoices' key")
                    return False
            elif isinstance(data, list):
                self.invoices = data
            else:
                logger.error("Invalid invoice file format: expected dict or list")
                return False
            
            # Filter only successful invoices
            successful_invoices = [inv for inv in self.invoices if inv.get('success', False)]
            self.invoices = successful_invoices
            
            logger.info(f"Loaded {len(self.invoices)} successful invoices from {invoices_file}")
            
            # Validate invoice format
            if self.invoices and isinstance(self.invoices[0], dict):
                required_fields = ['invoice_id', 'amount', 'currency', 'checkout_link']
                first_invoice = self.invoices[0]
                missing_fields = [field for field in required_fields if field not in first_invoice]
                if missing_fields:
                    logger.error(f"Invoice file missing required fields: {missing_fields}")
                    return False
            
            return True
            
        except FileNotFoundError:
            logger.error(f"Invoice file not found: {invoices_file}")
            return False
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in invoice file: {str(e)}")
            return False
        except Exception as e:
            logger.error(f"Error loading invoices: {str(e)}")
            return False
    
    def get_invoice_payment_info(self, invoice: Dict) -> Optional[Dict]:
        """
        Get Bitcoin payment information for a BTCPay invoice.
        
        Args:
            invoice (Dict): Invoice data
            
        Returns:
            Optional[Dict]: Payment information or None if failed
        """
        try:
            # Extract BTCPay server URL from checkout link
            checkout_link = invoice.get('checkout_link', '')
            if not checkout_link:
                logger.error(f"No checkout link for invoice {invoice.get('invoice_id')}")
                return None
            
            # Parse BTCPay server URL
            if '/i/' in checkout_link:
                base_url = checkout_link.split('/i/')[0]
                invoice_id = invoice.get('invoice_id')
            else:
                logger.error(f"Invalid checkout link format: {checkout_link}")
                return None
            
            # Get invoice details from BTCPay API
            api_url = f"{base_url}/i/{invoice_id}/status"
            response = requests.get(api_url, timeout=30)
            
            if response.status_code != 200:
                logger.error(f"Failed to get invoice details: HTTP {response.status_code}")
                return None
            
            invoice_data = response.json()
            
            # Extract Bitcoin payment information
            bitcoin_data = None
            payment_methods = invoice_data.get('availableCryptos', [])
            
            for method in payment_methods:
                if method.get('cryptoCode', '').upper() == 'BTC':
                    bitcoin_data = method
                    break
            
            if not bitcoin_data:
                logger.error(f"No Bitcoin payment method found for invoice {invoice_id}")
                return None
            
            payment_info = {
                'invoice_id': invoice_id,
                'btc_address': bitcoin_data.get('destination'),
                'btc_amount': float(bitcoin_data.get('due', 0)),
                'btc_amount_satoshis': int(float(bitcoin_data.get('due', 0)) * 100_000_000),
                'payment_url': bitcoin_data.get('paymentLink'),
                'qr_code_url': bitcoin_data.get('paymentUrls', {}).get('BIP21'),
                'status': invoice_data.get('status'),
                'expires_at': invoice_data.get('expirationTime')
            }
            
            return payment_info
            
        except Exception as e:
            logger.error(f"Error getting payment info for invoice {invoice.get('invoice_id')}: {str(e)}")
            return None
    
    def create_payment_transaction(self, payment_info: Dict, source_address: Dict) -> Optional[str]:
        """
        Create and send Bitcoin payment transaction.
        
        Args:
            payment_info (Dict): Payment information from BTCPay
            source_address (Dict): Source address with private key
            
        Returns:
            Optional[str]: Transaction ID if successful, None otherwise
        """
        try:
            # Create wallet from private key
            private_key = source_address['private_key']
            wallet_name = f"payment_wallet_{int(time.time())}_{random.randint(1000, 9999)}"
            
            try:
                # Create temporary wallet for this payment
                wallet = Wallet.create(
                    wallet_name,
                    keys=private_key,
                    network=self.network,
                    witness_type='segwit'
                )
                
                # Check wallet balance
                balance = wallet.balance()
                required_amount = payment_info['btc_amount_satoshis']
                fee_estimate = 10000  # 0.0001 BTC fee estimate
                
                if balance < (required_amount + fee_estimate):
                    logger.error(f"Insufficient balance in address {source_address['address']}: "
                               f"need {(required_amount + fee_estimate)} satoshis, have {balance}")
                    return None
                
                # Create transaction
                destination = payment_info['btc_address']
                
                logger.info(f"Sending {required_amount} satoshis to {destination}")
                
                # Send transaction
                tx = wallet.send([(destination, required_amount)], fee=fee_estimate)
                
                if tx:
                    logger.info(f"Payment sent successfully: {tx.txid}")
                    return tx.txid
                else:
                    logger.error("Failed to create transaction")
                    return None
                    
            finally:
                # Clean up temporary wallet
                try:
                    wallet.delete()
                except:
                    pass
                    
        except Exception as e:
            logger.error(f"Error creating payment transaction: {str(e)}")
            return None
    
    def pay_invoice(self, invoice: Dict, address_index: int = None) -> Tuple[bool, Dict]:
        """
        Pay a single BTCPay invoice using available addresses.
        
        Args:
            invoice (Dict): Invoice to pay
            address_index (int, optional): Specific address index to use
            
        Returns:
            Tuple[bool, Dict]: Success status and result data
        """
        try:
            invoice_id = invoice.get('invoice_id')
            logger.info(f"Processing payment for invoice {invoice_id}")
            
            # Get payment information
            payment_info = self.get_invoice_payment_info(invoice)
            if not payment_info:
                return False, {'error': 'Failed to get payment information'}
            
            # Check if invoice is still payable
            if payment_info['status'] not in ['New', 'Processing']:
                logger.warning(f"Invoice {invoice_id} status is {payment_info['status']}, skipping")
                return False, {'error': f"Invoice status: {payment_info['status']}"}
            
            # Select address to use for payment
            if address_index is not None:
                if address_index >= len(self.addresses):
                    return False, {'error': 'Address index out of range'}
                source_address = self.addresses[address_index]
            else:
                # Use random address
                source_address = random.choice(self.addresses)
            
            # Create and send payment
            tx_id = self.create_payment_transaction(payment_info, source_address)
            
            if tx_id:
                result = {
                    'invoice_id': invoice_id,
                    'transaction_id': tx_id,
                    'amount_btc': payment_info['btc_amount'],
                    'amount_satoshis': payment_info['btc_amount_satoshis'],
                    'source_address': source_address['address'],
                    'destination_address': payment_info['btc_address'],
                    'payment_time': datetime.now().isoformat(),
                    'success': True
                }
                
                self.stats['successful_payments'] += 1
                self.stats['total_amount_btc'] += payment_info['btc_amount']
                self.payment_results.append(result)
                
                return True, result
            else:
                error_result = {
                    'invoice_id': invoice_id,
                    'error': 'Failed to send transaction',
                    'payment_time': datetime.now().isoformat(),
                    'success': False
                }
                
                self.stats['failed_payments'] += 1
                self.failed_payments.append(error_result)
                
                return False, error_result
                
        except Exception as e:
            error_msg = str(e)
            logger.error(f"Error paying invoice {invoice.get('invoice_id')}: {error_msg}")
            
            error_result = {
                'invoice_id': invoice.get('invoice_id'),
                'error': error_msg,
                'payment_time': datetime.now().isoformat(),
                'success': False
            }
            
            self.stats['failed_payments'] += 1
            self.failed_payments.append(error_result)
            
            return False, error_result
    
    def pay_all_invoices(self, delay: float = 1.0, max_invoices: int = None) -> None:
        """
        Pay all loaded invoices using available addresses.
        
        Args:
            delay (float): Delay between payments in seconds
            max_invoices (int, optional): Maximum number of invoices to pay
        """
        if not self.addresses:
            logger.error("No addresses loaded")
            return
        
        if not self.invoices:
            logger.error("No invoices loaded")
            return
        
        invoices_to_pay = self.invoices[:max_invoices] if max_invoices else self.invoices
        self.stats['total_invoices'] = len(invoices_to_pay)
        self.stats['start_time'] = datetime.now()
        
        logger.info(f"Starting payment of {len(invoices_to_pay)} invoices using {len(self.addresses)} addresses")
        
        # Create progress bar
        pbar = tqdm(total=len(invoices_to_pay), desc="Paying invoices")
        
        for i, invoice in enumerate(invoices_to_pay):
            try:
                success, result = self.pay_invoice(invoice)
                
                if success:
                    logger.info(f"✅ Paid invoice {invoice.get('invoice_id')}: {result.get('transaction_id')}")
                else:
                    logger.error(f"❌ Failed to pay invoice {invoice.get('invoice_id')}: {result.get('error')}")
                
                pbar.update(1)
                
                # Delay between payments to avoid overwhelming servers
                if i < len(invoices_to_pay) - 1:
                    time.sleep(delay)
                    
            except KeyboardInterrupt:
                logger.info("Payment process interrupted by user")
                break
            except Exception as e:
                logger.error(f"Unexpected error processing invoice {invoice.get('invoice_id')}: {str(e)}")
                continue
        
        pbar.close()
        self.stats['end_time'] = datetime.now()
        self.print_summary()
    
    def print_summary(self) -> None:
        """Print payment summary statistics."""
        if not self.stats['start_time'] or not self.stats['end_time']:
            return
        
        duration = self.stats['end_time'] - self.stats['start_time']
        success_rate = (self.stats['successful_payments'] / self.stats['total_invoices']) * 100 if self.stats['total_invoices'] > 0 else 0
        
        print("\n" + "="*60)
        print("INVOICE PAYMENT SUMMARY")
        print("="*60)
        print(f"Total Invoices:     {self.stats['total_invoices']:,}")
        print(f"Successful:         {self.stats['successful_payments']:,}")
        print(f"Failed:             {self.stats['failed_payments']:,}")
        print(f"Success Rate:       {success_rate:.1f}%")
        print(f"Total Amount:       {self.stats['total_amount_btc']:.8f} BTC")
        print(f"Duration:           {duration}")
        if duration.total_seconds() > 0:
            print(f"Rate:               {self.stats['successful_payments'] / duration.total_seconds():.2f} payments/second")
        print("="*60)
    
    def export_results(self, output_dir: str = "payment_results") -> None:
        """
        Export payment results to JSON files.
        
        Args:
            output_dir (str): Directory to save result files
        """
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Export successful payments
        if self.payment_results:
            success_file = output_path / f"successful_payments_{timestamp}.json"
            with open(success_file, 'w') as f:
                json.dump({
                    'metadata': {
                        'total_count': len(self.payment_results),
                        'generated_at': datetime.now().isoformat(),
                        'network': self.network
                    },
                    'payments': self.payment_results
                }, f, indent=2)
            print(f"Successful payments exported to: {success_file}")
        
        # Export failed payments
        if self.failed_payments:
            failed_file = output_path / f"failed_payments_{timestamp}.json"
            with open(failed_file, 'w') as f:
                json.dump({
                    'metadata': {
                        'total_count': len(self.failed_payments),
                        'generated_at': datetime.now().isoformat(),
                        'network': self.network
                    },
                    'failed_payments': self.failed_payments
                }, f, indent=2)
            print(f"Failed payments exported to: {failed_file}")
        
        # Export summary statistics
        summary_file = output_path / f"payment_summary_{timestamp}.json"
        with open(summary_file, 'w') as f:
            json.dump({
                'statistics': {
                    **self.stats,
                    'start_time': self.stats['start_time'].isoformat() if self.stats['start_time'] else None,
                    'end_time': self.stats['end_time'].isoformat() if self.stats['end_time'] else None,
                    'success_rate_percent': (self.stats['successful_payments'] / self.stats['total_invoices']) * 100 if self.stats['total_invoices'] > 0 else 0
                },
                'configuration': {
                    'network': self.network
                }
            }, f, indent=2)
        print(f"Summary statistics exported to: {summary_file}")


def load_config(config_file: str) -> Dict:
    """
    Load configuration from JSON file.
    
    Args:
        config_file (str): Path to configuration file
        
    Returns:
        Dict: Configuration dictionary
    """
    try:
        with open(config_file, 'r') as f:
            config = json.load(f)
        logger.info(f"Loaded configuration from {config_file}")
        return config
    except FileNotFoundError:
        logger.error(f"Configuration file not found: {config_file}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in configuration file: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"Error loading configuration: {str(e)}")
        raise


def validate_config(config: Dict) -> bool:
    """
    Validate configuration file values.
    
    Args:
        config (Dict): Configuration dictionary
        
    Returns:
        bool: True if valid, False otherwise
    """
    required_fields = ['addresses_file', 'invoices_file']
    for field in required_fields:
        if field not in config:
            logger.error(f"Config error: missing required field '{field}'")
            return False
    
    # Validate optional numeric fields
    numeric_fields = ['max_invoices', 'delay']
    for field in numeric_fields:
        if field in config and not isinstance(config[field], (int, float)):
            logger.error(f"Config error: '{field}' must be a number")
            return False
    
    # Validate boolean fields
    if 'mainnet' in config and not isinstance(config['mainnet'], bool):
        logger.error("Config error: 'mainnet' must be a boolean")
        return False
    
    return True


def merge_config_with_args(config: Dict, args: argparse.Namespace) -> argparse.Namespace:
    """
    Merge configuration file values with command line arguments.
    Command line arguments take precedence over config file values.
    Supports both legacy config format and universal config format.
    
    Args:
        config (Dict): Configuration dictionary
        args (argparse.Namespace): Command line arguments
        
    Returns:
        argparse.Namespace: Merged arguments
    """
    # Handle universal config format
    if '_payment_processing' in config:
        # Universal config format
        payment_config = config['_payment_processing']
        network_config = config.get('_network_settings', {})
        
        if not args.addresses and 'addresses_file' in payment_config:
            args.addresses = payment_config['addresses_file']
        
        if not args.invoices and 'invoices_file' in payment_config:
            args.invoices = payment_config['invoices_file']
        
        if not args.mainnet and network_config.get('mainnet', False):
            args.mainnet = network_config['mainnet']
        
        if args.delay == 1.0 and 'delay' in payment_config:  # Default value check
            args.delay = payment_config['delay']
        
        if not args.max_invoices and 'max_invoices' in payment_config:
            args.max_invoices = payment_config['max_invoices']
        
        if args.output_dir == 'payment_results' and 'output_dir' in payment_config:  # Default value check
            args.output_dir = payment_config['output_dir']
    
    else:
        # Legacy config format
        if not args.addresses and 'addresses_file' in config:
            args.addresses = config['addresses_file']
        
        if not args.invoices and 'invoices_file' in config:
            args.invoices = config['invoices_file']
        
        if not args.mainnet and config.get('mainnet', False):
            args.mainnet = config['mainnet']
        
        if args.delay == 1.0 and 'delay' in config:  # Default value check
            args.delay = config['delay']
        
        if not args.max_invoices and 'max_invoices' in config:
            args.max_invoices = config['max_invoices']
        
        if args.output_dir == 'payment_results' and 'output_dir' in config:  # Default value check
            args.output_dir = config['output_dir']
    
    return args


def main():
    """Main function with command line interface."""
    parser = argparse.ArgumentParser(
        description='Pay BTCPay Server invoices using generated Bitcoin addresses',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --addresses generated_addresses.json --invoices successful_invoices.json
  %(prog)s --config payment_config.json
  %(prog)s --addresses addresses.json --invoices invoices.json --mainnet --delay 2.0
        """
    )
    
    parser.add_argument('--config', type=str, help='Configuration file path (JSON format)')
    parser.add_argument('--addresses', type=str, help='Generated addresses JSON file')
    parser.add_argument('--invoices', type=str, help='Generated invoices JSON file')
    parser.add_argument('--mainnet', action='store_true', help='Use mainnet instead of testnet')
    parser.add_argument('--delay', type=float, default=1.0, help='Delay between payments in seconds (default: 1.0)')
    parser.add_argument('--max-invoices', type=int, help='Maximum number of invoices to pay')
    parser.add_argument('--output-dir', default='payment_results', help='Output directory for result files (default: payment_results)')
    parser.add_argument('--test-only', action='store_true', help='Only test loading files, do not make payments')
    
    args = parser.parse_args()
    
    # Load configuration file if provided
    if args.config:
        try:
            config = load_config(args.config)
            if not validate_config(config):
                print(f"❌ Configuration validation failed")
                return 1
            args = merge_config_with_args(config, args)
            print(f"✅ Loaded configuration from: {args.config}")
        except Exception as e:
            print(f"❌ Error loading configuration: {str(e)}")
            return 1
    
    # Validate required arguments
    if not args.addresses:
        print("❌ Error: --addresses is required (or specify in config file)")
        return 1
    
    if not args.invoices:
        print("❌ Error: --invoices is required (or specify in config file)")
        return 1
    
    # Warning for mainnet usage
    if args.mainnet:
        print("\n⚠️  WARNING: You are about to make payments on Bitcoin MAINNET!")
        print("This will use real Bitcoin. Make sure this is intended.")
        response = input("Continue? (yes/no): ").lower().strip()
        if response != 'yes':
            print("Operation cancelled.")
            return 0
    
    try:
        # Initialize payment processor
        network = 'bitcoin' if args.mainnet else 'testnet'
        processor = BTCPayInvoicePayment(network=network)
        
        # Load addresses and invoices
        print("Loading addresses...")
        if not processor.load_addresses(args.addresses):
            print("❌ Failed to load addresses")
            return 1
        
        print("Loading invoices...")
        if not processor.load_invoices(args.invoices):
            print("❌ Failed to load invoices")
            return 1
        
        print(f"✅ Loaded {len(processor.addresses)} addresses and {len(processor.invoices)} invoices")
        
        if args.test_only:
            print("Test completed successfully. Use without --test-only to make payments.")
            return 0
        
        # Pay invoices
        print(f"\nStarting payment process...")
        processor.pay_all_invoices(
            delay=args.delay,
            max_invoices=args.max_invoices
        )
        
        # Export results
        processor.export_results(args.output_dir)
        
        if processor.stats['successful_payments'] > 0:
            print(f"\n✅ Successfully paid {processor.stats['successful_payments']:,} invoices!")
        
        if processor.stats['failed_payments'] > 0:
            print(f"⚠️  {processor.stats['failed_payments']:,} payments failed.")
            print("Check the failed_payments_*.json file for details.")
        
        return 0 if processor.stats['failed_payments'] == 0 else 1
        
    except KeyboardInterrupt:
        print("\n\n⚠️  Payment process interrupted by user")
        if 'processor' in locals():
            processor.export_results(args.output_dir)
        return 1
    except Exception as e:
        print(f"\n❌ Unexpected error: {str(e)}")
        logger.error(f"Unexpected error: {str(e)}", exc_info=True)
        return 1


if __name__ == "__main__":
    exit(main())
