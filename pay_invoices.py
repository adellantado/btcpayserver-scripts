#!/usr/bin/env python3
"""
BTCPay Invoice Payment Script

This script pays BTCPay Server invoices using Bitcoin addresses generated by generate_addresses.py.
It loads generated addresses and invoices, then automatically pays the invoices using the Bitcoin
from the generated addresses.

Requirements:
- bitcoinlib
- requests
- Generated addresses file from generate_addresses.py
- Generated invoices file from generate_invoices.py

Usage:
    python pay_invoices.py --addresses addresses.json --invoices invoices.json
    python pay_invoices.py --config payment_config.json
"""

import argparse
import json
import logging
import os
import time
import random
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from decimal import Decimal

import requests
from tqdm import tqdm

try:
    from bitcoinlib.wallets import Wallet
    from bitcoinlib.keys import HDKey
    from bitcoinlib.transactions import Transaction
    from bitcoinlib.services.services import Service
except ImportError:
    print("Error: bitcoinlib not installed. Install with: pip install bitcoinlib")
    exit(1)

# Configure logging
os.makedirs('logs', exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/invoice_payment.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class BTCPayInvoicePayment:
    """BTCPay Server invoice payment processor using generated Bitcoin addresses."""
    
    def __init__(self, network='testnet', store_id=None, base_url=None, api_key=None):
        """
        Initialize the invoice payment processor.
        
        Args:
            network (str): Network type ('bitcoin' for mainnet, 'testnet' for testnet)
            store_id (str): BTCPay Server store ID
            base_url (str): BTCPay Server base URL
            api_key (str): BTCPay Server API key
        """
        self.network = network
        self.store_id = store_id
        self.base_url = base_url
        self.api_key = api_key
        self.addresses = []
        self.invoices = []
        self.payment_results = []
        self.failed_payments = []
        self.current_address_index = 0  # Track which address to use next
        self.funding_wallet = None
        
        # Statistics tracking
        self.stats = {
            'total_invoices': 0,
            'successful_payments': 0,
            'failed_payments': 0,
            'total_amount_btc': 0.0,
            'start_time': None,
            'end_time': None
        }
        
        logger.info(f"Initialized BTCPayInvoicePayment for {self.network}")
    
    def recreate_funding_wallet(self) -> None:
        """
        Recreate the funding wallet for payments.
        This method creates a new funding wallet that can be used for transactions.
        """
        try:
            # Delete existing funding wallet if it exists
            if self.funding_wallet:
                try:
                    self.funding_wallet.delete()
                    logger.info("Deleted existing funding wallet")
                except Exception as e:
                    logger.warning(f"Could not delete existing funding wallet: {e}")
            
            
            wallet_name = "wallet_1"
            # Try to load existing wallet
            
            self.funding_wallet = Wallet(wallet_name)
            
            logger.info(f"Created new funding wallet: {wallet_name}")
            logger.info(f"Funding wallet address: {self.funding_wallet.addresslist()[0]}")
            
        except Exception as e:
            logger.error(f"Error recreating funding wallet: {str(e)}")
            self.funding_wallet = None
    
    def load_addresses(self, addresses_file: str) -> bool:
        """
        Load generated addresses from JSON file.
        
        Args:
            addresses_file (str): Path to generated addresses file
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            with open(addresses_file, 'r') as f:
                self.addresses = json.load(f)
            
            logger.info(f"Loaded {len(self.addresses)} addresses from {addresses_file}")
            
            # Validate address format and normalize private key field
            if self.addresses and isinstance(self.addresses[0], dict):
                first_addr = self.addresses[0]
                
                # Check for required fields
                required_fields = ['address', 'network']
                missing_fields = [field for field in required_fields if field not in first_addr]
                
                # Check for private key in either 'private_key' or 'wif' field
                has_private_key = 'private_key' in first_addr or 'wif' in first_addr
                if not has_private_key:
                    missing_fields.append('private_key or wif')
                
                if missing_fields:
                    logger.error(f"Address file missing required fields: {missing_fields}")
                    return False
                
                # Normalize private key field - convert 'wif' to 'private_key' if needed
                for addr in self.addresses:
                    if 'wif' in addr and 'private_key' not in addr:
                        addr['private_key'] = addr['wif']
            
            return True
            
        except FileNotFoundError:
            logger.error(f"Address file not found: {addresses_file}")
            return False
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in address file: {str(e)}")
            return False
        except Exception as e:
            logger.error(f"Error loading addresses: {str(e)}")
            return False
    
    def load_invoices(self, invoices_file: str) -> bool:
        """
        Load generated invoices from JSON file.
        
        Args:
            invoices_file (str): Path to generated invoices file (supports wildcards)
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Handle wildcard patterns
            if '*' in invoices_file:
                import glob
                matching_files = glob.glob(invoices_file)
                if not matching_files:
                    logger.error(f"No files found matching pattern: {invoices_file}")
                    return False
                
                # Use the most recent file if multiple matches
                invoices_file = max(matching_files, key=lambda f: Path(f).stat().st_mtime)
                logger.info(f"Using most recent file: {invoices_file}")
            
            with open(invoices_file, 'r') as f:
                data = json.load(f)
            
            # Handle different invoice file formats
            if isinstance(data, dict):
                if 'invoices' in data:
                    self.invoices = data['invoices']
                elif 'generated_invoices' in data:
                    self.invoices = data['generated_invoices']
                else:
                    logger.error("Invalid invoice file format: missing 'invoices' or 'generated_invoices' key")
                    return False
            elif isinstance(data, list):
                self.invoices = data
            else:
                logger.error("Invalid invoice file format: expected dict or list")
                return False
            
            # Filter only successful invoices
            successful_invoices = [inv for inv in self.invoices if inv.get('success', False)]
            self.invoices = successful_invoices
            
            logger.info(f"Loaded {len(self.invoices)} successful invoices from {invoices_file}")
            
            # Validate invoice format
            if self.invoices and isinstance(self.invoices[0], dict):
                required_fields = ['invoice_id', 'amount', 'currency', 'checkout_link']
                first_invoice = self.invoices[0]
                missing_fields = [field for field in required_fields if field not in first_invoice]
                if missing_fields:
                    logger.error(f"Invoice file missing required fields: {missing_fields}")
                    return False
            
            return True
            
        except FileNotFoundError:
            logger.error(f"Invoice file not found: {invoices_file}")
            return False
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in invoice file: {str(e)}")
            return False
        except Exception as e:
            logger.error(f"Error loading invoices: {str(e)}")
            return False
    
    def get_invoice_payment_info(self, invoice: Dict, store_id: str, base_url: str, api_key: str) -> Optional[Dict]:
        """
        Get Bitcoin payment information for a BTCPay invoice.
        
        Args:
            invoice (Dict): Invoice data
            store_id (str): BTCPay Server store ID
            base_url (str): BTCPay Server base URL
            api_key (str): BTCPay Server API key
            
        Returns:
            Optional[Dict]: Payment information or None if failed
        """
        try:
            invoice_id = invoice.get('invoice_id')
            if not invoice_id:
                logger.error(f"No invoice ID found in invoice data")
                return None
            
            # Use the correct BTCPay Server API endpoint
            api_url = f"{base_url.rstrip('/')}/api/v1/stores/{store_id}/invoices/{invoice_id}/payment-methods"
            
            headers = {
                'Authorization': f'token {api_key}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            
            response = requests.get(api_url, headers=headers, timeout=30)
            
            if response.status_code != 200:
                logger.error(f"Failed to get invoice details: HTTP {response.status_code}")
                return None
            
            # Response is an array, get the first invoice
            invoice_data_list = response.json()
            if not invoice_data_list or len(invoice_data_list) == 0:
                logger.error(f"No invoice data returned for invoice {invoice_id}")
                return None
            
            invoice_data = [paymethod for paymethod in invoice_data_list if paymethod.get('paymentMethodId') == 'BTC-CHAIN'][0]

            logger.info(f"Payment data: {invoice_data}")
            
            # Extract payment information from the response
            payment_info = {
                'btc_address': invoice_data['destination'],
                'btc_amount': float(invoice_data.get('amount')),
                'btc_amount_satoshis': int(float(invoice_data.get('amount')) * 100_000_000),
                'amount': invoice_data.get('amount'),
                'paid_amount': invoice_data.get('totalPaid'),
                'currency': invoice_data.get('currency'),
                'status': invoice_data.get('status', 'New'),
            }
            
            return payment_info
            
        except Exception as e:
            logger.error(f"Error getting payment info for invoice {invoice.get('invoice_id')}: {str(e)}")
            return None
    
    def create_payment_transaction(self, payment_info: Dict, source_address: Dict) -> Optional[str]:
        """
        Create and send Bitcoin payment transaction.
        
        Args:
            payment_info (Dict): Payment information from BTCPay
            source_address (Dict): Source address with private key
            
        Returns:
            Optional[str]: Transaction ID if successful, None otherwise
        """
        try:
            # Create wallet from private key
            private_key = source_address.get('private_key') or source_address.get('wif')
            wallet_name = f"payment_wallet_{int(time.time())}_{random.randint(1000, 9999)}"
            tx = None
            try:
                check_utxos = False
                if not self.funding_wallet:
                    # Create temporary wallet for this payment
                    wallet = Wallet.create(
                        wallet_name,
                        keys=private_key,
                        network=self.network,
                        witness_type='segwit'
                    )
                    check_utxos = True
                    if wallet.get_key(0).address != source_address['address']:
                        logger.error(f"Address mismatch: {wallet.get_key(0).address} != {source_address['address']}")
                        self.recreate_funding_wallet()
                        check_utxos = True
                        logger.info(f"Recreated funding wallet")
                        wallet = self.funding_wallet
                        balance = self.get_wallet_balance(wallet)
                else:
                    wallet = self.funding_wallet
                    check_utxos = False

                if not self.funding_wallet:
                    # Check wallet balance
                    balance = self.get_wallet_balance(wallet)
                required_amount = payment_info['btc_amount_satoshis']
                fee_estimate = 10000  # 0.0001 BTC fee estimate
                
                # if balance < (required_amount + fee_estimate):
                #     logger.error(f"Insufficient balance in address {source_address['address']}: "
                #                f"need {(required_amount + fee_estimate)} satoshis, have {balance}")
                #     return None
                
                # Validate UTXOs before attempting transactions
                if check_utxos:
                    logger.info("Validating wallet UTXOs...")
                    try:
                        utxos = wallet.utxos()
                        if not utxos:
                            logger.error("No UTXOs available for spending. Wallet may not be properly synchronized.")
                            logger.info("Attempting to force wallet synchronization...")
                            try:
                                wallet.utxos_update()
                                utxos = wallet.utxos()
                                if not utxos:
                                    logger.error("Failed to synchronize UTXOs. Cannot create transactions.")
                                    return None
                                else:
                                    logger.info(f"Successfully synchronized {len(utxos)} UTXOs")
                            except Exception as sync_error:
                                logger.error(f"Failed to synchronize wallet: {sync_error}")
                                return None
                        else:
                            logger.info(f"Found {len(utxos)} UTXOs available for spending")
                    except Exception as e:
                        logger.error(f"Error validating UTXOs: {e}")
                        return None

                # Create transaction
                destination = payment_info['btc_address']
                
                logger.info(f"Sending {required_amount} satoshis to {destination}")
                
                # Send transaction
                if not self.funding_wallet:
                    tx = wallet.send([(destination, required_amount)], fee=fee_estimate)
                else:
                    tx = self.funding_wallet.send([(destination, required_amount)], input_key_id=source_address['key_id'], fee=fee_estimate)
                
                if tx and tx.txid:
                    # Verify transaction was actually created and broadcasted
                    logger.info(f"Transaction created: {tx.txid}")
                    
                    # Wait a moment and verify the transaction exists
                    time.sleep(3)
                    
                    # Try to verify transaction was broadcasted by checking if it exists
                    broadcasted = False
                    try:
                        from bitcoinlib.services.services import Service
                        service = Service(network=self.network)
                        tx_info = service.gettransaction(tx.txid)
                        if tx_info:
                            broadcasted = True
                            logger.info(f"✅ Transaction verified on network: {tx.txid}")
                        else:
                            logger.warning(f"⚠️  Transaction {tx.txid} not found on network, attempting manual broadcast...")
                            
                            # Try manual broadcasting
                            if hasattr(tx, 'raw_hex'):
                                broadcasted = self.manual_broadcast_transaction(tx.raw_hex())
                            else:
                                logger.warning("Cannot get raw transaction hex for manual broadcasting")
                                
                    except Exception as verify_error:
                        logger.warning(f"Could not verify transaction {tx.txid}: {verify_error}")
                        
                        # Try manual broadcasting as fallback
                        try:
                            if hasattr(tx, 'raw_hex'):
                                broadcasted = self.manual_broadcast_transaction(tx.raw_hex())
                        except Exception as broadcast_error:
                            logger.warning(f"Manual broadcasting failed: {broadcast_error}")
                    
                    if broadcasted:
                        logger.info(f"✅ Transaction broadcasted: {tx.txid}")
                    else:
                        logger.warning(f"⚠️  Transaction {tx.txid} created but may not be broadcasted")
                    
                    # Add small delay between batches to avoid overwhelming the network
                    time.sleep(2)
                else:
                    logger.error(f"Failed to create transaction")
                    
            finally:
                # Clean up temporary wallet
                try:
                    if not self.funding_wallet:
                        wallet.delete()
                except:
                    pass
                if tx and tx.txid:
                    return tx.txid
                else:
                    return None
                    
        except Exception as e:
            logger.error(f"Error creating payment transaction: {str(e)}")
            return None
    
    def get_wallet_balance(self, wallet: Wallet) -> int:
        """
        Get the current balance of the wallet.
        
        Returns:
            int: Balance in satoshis
        """
        
        try:
            # First try the wallet's internal balance
            balance = wallet.balance()
            
            # If balance is 0, try to get it from the service provider directly
            if balance == 0:
                logger.info(f"Wallet internal balance is 0, trying to get it from the service provider")
                try:
                    from bitcoinlib.services.services import Service
                    service = Service(network=self.network)
                    main_address = wallet.addresslist()[0]
                    logger.info(f"Getting balance from service for address: {main_address}")
                    service_balance = service.getbalance(main_address)
                    if service_balance > 0:
                        logger.info(f"Wallet internal balance is 0, but service shows {service_balance} satoshis. Updating wallet...")
                        # Try to update the wallet's UTXOs
                        try:
                            wallet.utxos_update()
                            # Check balance again after update
                            balance = wallet.balance()
                            if balance > 0:
                                logger.info(f"Wallet update successful, balance now: {balance} satoshis")
                                return balance
                        except Exception as update_error:
                            logger.warning(f"Wallet UTXO update failed: {update_error}")
                        
                        # If wallet update failed, use service balance directly
                        logger.info(f"Using service balance directly: {service_balance} satoshis")
                        return service_balance
                except Exception as service_error:
                    logger.warning(f"Could not get balance from service: {service_error}")
            
            return balance
        except Exception as e:
            logger.error(f"Error getting wallet balance: {str(e)}")
            return 0

    def manual_broadcast_transaction(self, tx_hex: str) -> bool:
        """
        Manually broadcast a transaction using alternative methods.
        
        Args:
            tx_hex (str): Raw transaction hex string
            
        Returns:
            bool: True if broadcasted successfully, False otherwise
        """
        try:
            # Method 1: Try using requests to broadcast to multiple testnet APIs
            import requests
            
            testnet_apis = [
                "https://blockstream.info/testnet/api/tx",
                "https://mempool.space/testnet/api/tx",
                "https://api.blockcypher.com/v1/btc/test3/txs/push"
            ]
            
            for api_url in testnet_apis:
                try:
                    response = requests.post(api_url, data=tx_hex, timeout=10)
                    if response.status_code in [200, 201]:
                        logger.info(f"✅ Transaction broadcasted via {api_url}")
                        return True
                except Exception as e:
                    logger.debug(f"Failed to broadcast via {api_url}: {e}")
                    continue
            
            # Method 2: Try using bitcoinlib's raw transaction broadcasting
            try:
                from bitcoinlib.services.services import Service
                service = Service(network=self.network)
                result = service.sendrawtransaction(tx_hex)
                if result:
                    logger.info("✅ Transaction broadcasted via bitcoinlib service")
                    return True
            except Exception as e:
                logger.debug(f"Failed to broadcast via bitcoinlib service: {e}")
            
            logger.warning("❌ All broadcasting methods failed")
            return False
            
        except Exception as e:
            logger.error(f"Error in manual broadcasting: {e}")
            return False

    def pay_invoice(self, invoice: Dict, address_index: int = None, test_only: bool = False) -> Tuple[bool, Dict]:
        """
        Pay a single BTCPay invoice using available addresses.
        
        Args:
            invoice (Dict): Invoice to pay
            address_index (int, optional): Specific address index to use
            
        Returns:
            Tuple[bool, Dict]: Success status and result data
        """
        try:
            invoice_id = invoice.get('invoice_id')
            logger.info(f"Processing payment for invoice {invoice_id}")
            
            # Get payment information
            payment_info = self.get_invoice_payment_info(invoice, self.store_id, self.base_url, self.api_key)
            if not payment_info:
                return False, {'error': 'Failed to get payment information'}
            
            # Check if invoice is still payable
            if payment_info['status'] not in ['New', 'Processing']:
                logger.warning(f"Invoice {invoice_id} status is {payment_info['status']}, skipping")
                return False, {'error': f"Invoice status: {payment_info['status']}"}
            
            # Select address to use for payment
            if address_index is not None:
                if address_index >= len(self.addresses):
                    return False, {'error': 'Address index out of range'}
                source_address = self.addresses[address_index]
            else:
                # Use next address in sequence
                if self.current_address_index >= len(self.addresses):
                    # Reset to beginning if we've used all addresses
                    self.current_address_index = 0
                source_address = self.addresses[self.current_address_index]
                logger.info(f"Using address {self.current_address_index + 1}/{len(self.addresses)}: {source_address['address']}")
                self.current_address_index += 1
            
            # Create and send payment
            if not test_only:
                tx_id = self.create_payment_transaction(payment_info, source_address)
            else:
                tx_id = None
                return True, {'transaction_id': tx_id}
            
            if tx_id:
                result = {
                    'invoice_id': invoice_id,
                    'transaction_id': tx_id,
                    'amount_btc': payment_info['btc_amount'],
                    'amount_satoshis': payment_info['btc_amount_satoshis'],
                    'source_address': source_address['address'],
                    'destination_address': payment_info['btc_address'],
                    'payment_time': datetime.now().isoformat(),
                    'success': True
                }
                
                self.stats['successful_payments'] += 1
                self.stats['total_amount_btc'] += payment_info['btc_amount']
                self.payment_results.append(result)
                
                return True, result
            else:
                error_result = {
                    'invoice_id': invoice_id,
                    'error': 'Failed to send transaction',
                    'payment_time': datetime.now().isoformat(),
                    'success': False
                }
                
                self.stats['failed_payments'] += 1
                self.failed_payments.append(error_result)
                
                return False, error_result
                
        except Exception as e:
            error_msg = str(e)
            logger.error(f"Error paying invoice {invoice.get('invoice_id')}: {error_msg}")
            
            error_result = {
                'invoice_id': invoice.get('invoice_id'),
                'error': error_msg,
                'payment_time': datetime.now().isoformat(),
                'success': False
            }
            
            self.stats['failed_payments'] += 1
            self.failed_payments.append(error_result)
            
            return False, error_result
    
    def pay_all_invoices(self, delay: float = 1.0, max_invoices: int = None, test_only: bool = False) -> None:
        """
        Pay all loaded invoices using available addresses.
        
        Args:
            delay (float): Delay between payments in seconds
            max_invoices (int, optional): Maximum number of invoices to pay
        """
        if not self.addresses:
            logger.error("No addresses loaded")
            return
        
        if not self.invoices:
            logger.error("No invoices loaded")
            return
        
        invoices_to_pay = self.invoices[:max_invoices] if max_invoices else self.invoices
        self.stats['total_invoices'] = len(invoices_to_pay)
        self.stats['start_time'] = datetime.now()
        
        logger.info(f"Starting payment of {len(invoices_to_pay)} invoices using {len(self.addresses)} addresses")
        
        # Create progress bar
        pbar = tqdm(total=len(invoices_to_pay), desc="Paying invoices")
        
        for i, invoice in enumerate(invoices_to_pay):
            try:
                success, result = self.pay_invoice(invoice, test_only=test_only)
                
                if success:
                    logger.info(f"✅ Paid invoice {invoice.get('invoice_id')}: {result.get('transaction_id')}")
                else:
                    logger.error(f"❌ Failed to pay invoice {invoice.get('invoice_id')}: {result.get('error')}")
                
                pbar.update(1)
                
                # Delay between payments to avoid overwhelming servers
                if i < len(invoices_to_pay) - 1:
                    time.sleep(delay)
                    
            except KeyboardInterrupt:
                logger.info("Payment process interrupted by user")
                break
            except Exception as e:
                logger.error(f"Unexpected error processing invoice {invoice.get('invoice_id')}: {str(e)}")
                continue
        
        pbar.close()
        self.stats['end_time'] = datetime.now()
        self.print_summary()
    
    def print_summary(self) -> None:
        """Print payment summary statistics."""
        if not self.stats['start_time'] or not self.stats['end_time']:
            return
        
        duration = self.stats['end_time'] - self.stats['start_time']
        success_rate = (self.stats['successful_payments'] / self.stats['total_invoices']) * 100 if self.stats['total_invoices'] > 0 else 0
        
        print("\n" + "="*60)
        print("INVOICE PAYMENT SUMMARY")
        print("="*60)
        print(f"Total Invoices:     {self.stats['total_invoices']:,}")
        print(f"Successful:         {self.stats['successful_payments']:,}")
        print(f"Failed:             {self.stats['failed_payments']:,}")
        print(f"Success Rate:       {success_rate:.1f}%")
        print(f"Total Amount:       {self.stats['total_amount_btc']:.8f} BTC")
        print(f"Duration:           {duration}")
        if duration.total_seconds() > 0:
            print(f"Rate:               {self.stats['successful_payments'] / duration.total_seconds():.2f} payments/second")
        print("="*60)
    
    def export_results(self, output_dir: str = "payment_results") -> None:
        """
        Export payment results to JSON files.
        
        Args:
            output_dir (str): Directory to save result files
        """
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Export successful payments
        if self.payment_results:
            success_file = output_path / f"successful_payments_{timestamp}.json"
            with open(success_file, 'w') as f:
                json.dump({
                    'metadata': {
                        'total_count': len(self.payment_results),
                        'generated_at': datetime.now().isoformat(),
                        'network': self.network
                    },
                    'payments': self.payment_results
                }, f, indent=2)
            print(f"Successful payments exported to: {success_file}")
        
        # Export failed payments
        if self.failed_payments:
            failed_file = output_path / f"failed_payments_{timestamp}.json"
            with open(failed_file, 'w') as f:
                json.dump({
                    'metadata': {
                        'total_count': len(self.failed_payments),
                        'generated_at': datetime.now().isoformat(),
                        'network': self.network
                    },
                    'failed_payments': self.failed_payments
                }, f, indent=2)
            print(f"Failed payments exported to: {failed_file}")
        
        # Export summary statistics
        summary_file = output_path / f"payment_summary_{timestamp}.json"
        with open(summary_file, 'w') as f:
            json.dump({
                'statistics': {
                    **self.stats,
                    'start_time': self.stats['start_time'].isoformat() if self.stats['start_time'] else None,
                    'end_time': self.stats['end_time'].isoformat() if self.stats['end_time'] else None,
                    'success_rate_percent': (self.stats['successful_payments'] / self.stats['total_invoices']) * 100 if self.stats['total_invoices'] > 0 else 0
                },
                'configuration': {
                    'network': self.network
                }
            }, f, indent=2)
        print(f"Summary statistics exported to: {summary_file}")


def load_config(config_file: str) -> Dict:
    """
    Load configuration from JSON file.
    
    Args:
        config_file (str): Path to configuration file
        
    Returns:
        Dict: Configuration dictionary
    """
    try:
        with open(config_file, 'r') as f:
            config = json.load(f)
        logger.info(f"Loaded configuration from {config_file}")
        return config
    except FileNotFoundError:
        logger.error(f"Configuration file not found: {config_file}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in configuration file: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"Error loading configuration: {str(e)}")
        raise


def validate_config(config: Dict) -> bool:
    """
    Validate configuration file values.
    
    Args:
        config (Dict): Configuration dictionary
        
    Returns:
        bool: True if valid, False otherwise
    """
    # Handle universal config format
    if '_payment_processing' in config:
        # Universal config format - check _payment_processing section
        payment_config = config['_payment_processing']
        required_fields = ['addresses_file', 'invoices_file']
        for field in required_fields:
            if field not in payment_config:
                logger.error(f"Config error: missing required field '{field}' in _payment_processing section")
                return False
        
        # Validate optional numeric fields in _payment_processing section
        numeric_fields = ['max_invoices', 'delay']
        for field in numeric_fields:
            if field in payment_config and not isinstance(payment_config[field], (int, float)):
                logger.error(f"Config error: '{field}' must be a number")
                return False
    else:
        # Legacy config format - check root level
        required_fields = ['addresses_file', 'invoices_file']
        for field in required_fields:
            if field not in config:
                logger.error(f"Config error: missing required field '{field}'")
                return False
        
        # Validate optional numeric fields
        numeric_fields = ['max_invoices', 'delay']
        for field in numeric_fields:
            if field in config and not isinstance(config[field], (int, float)):
                logger.error(f"Config error: '{field}' must be a number")
                return False
    
    # Validate boolean fields (check both formats)
    mainnet_config = config.get('_network_settings', {}).get('mainnet') if '_network_settings' in config else config.get('mainnet')
    if mainnet_config is not None and not isinstance(mainnet_config, bool):
        logger.error("Config error: 'mainnet' must be a boolean")
        return False
    
    return True


def merge_config_with_args(config: Dict, args: argparse.Namespace) -> argparse.Namespace:
    """
    Merge configuration file values with command line arguments.
    Command line arguments take precedence over config file values.
    Supports both legacy config format and universal config format.
    
    Args:
        config (Dict): Configuration dictionary
        args (argparse.Namespace): Command line arguments
        
    Returns:
        argparse.Namespace: Merged arguments
    """
    # Handle universal config format
    if '_payment_processing' in config:
        # Universal config format
        payment_config = config['_payment_processing']
        network_config = config.get('_network_settings', {})
        
        if not args.addresses and 'addresses_file' in payment_config:
            args.addresses = payment_config['addresses_file']
        
        if not args.invoices and 'invoices_file' in payment_config:
            args.invoices = payment_config['invoices_file']
        
        if not args.mainnet and network_config.get('mainnet', False):
            args.mainnet = network_config['mainnet']
        
        if args.delay == 1.0 and 'delay' in payment_config:  # Default value check
            args.delay = payment_config['delay']
        
        if not args.max_invoices and 'max_invoices' in payment_config:
            args.max_invoices = payment_config['max_invoices']
        
        if args.output_dir == 'payment_results' and 'output_dir' in payment_config:  # Default value check
            args.output_dir = payment_config['output_dir']
        
        # BTCPay Server configuration (from _invoice_generation section)
        invoice_config = config.get('_invoice_generation', {})
        if not args.store_id and 'store_id' in invoice_config:
            args.store_id = invoice_config['store_id']
        
        if not args.base_url and 'base_url' in invoice_config:
            args.base_url = invoice_config['base_url']
        
        if not args.api_key and 'api_key' in invoice_config:
            args.api_key = invoice_config['api_key']
    
    else:
        # Legacy config format
        if not args.addresses and 'addresses_file' in config:
            args.addresses = config['addresses_file']
        
        if not args.invoices and 'invoices_file' in config:
            args.invoices = config['invoices_file']
        
        if not args.mainnet and config.get('mainnet', False):
            args.mainnet = config['mainnet']
        
        if args.delay == 1.0 and 'delay' in config:  # Default value check
            args.delay = config['delay']
        
        if not args.max_invoices and 'max_invoices' in config:
            args.max_invoices = config['max_invoices']
        
        if args.output_dir == 'payment_results' and 'output_dir' in config:  # Default value check
            args.output_dir = config['output_dir']
        
        # BTCPay Server configuration
        if not args.store_id and 'store_id' in config:
            args.store_id = config['store_id']
        
        if not args.base_url and 'base_url' in config:
            args.base_url = config['base_url']
        
        if not args.api_key and 'api_key' in config:
            args.api_key = config['api_key']
    
    return args


def main():
    """Main function with command line interface."""
    parser = argparse.ArgumentParser(
        description='Pay BTCPay Server invoices using generated Bitcoin addresses',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --addresses generated_addresses.json --invoices successful_invoices.json --store-id store123 --base-url https://btcpay.example.com --api-key abc123
  %(prog)s --config payment_config.json
  %(prog)s --addresses addresses.json --invoices invoices.json --mainnet --delay 2.0 --store-id store123 --base-url https://btcpay.example.com --api-key abc123
        """
    )
    
    parser.add_argument('--config', type=str, help='Configuration file path (JSON format)')
    parser.add_argument('--addresses', type=str, help='Generated addresses JSON file')
    parser.add_argument('--invoices', type=str, help='Generated invoices JSON file')
    parser.add_argument('--mainnet', action='store_true', help='Use mainnet instead of testnet')
    parser.add_argument('--delay', type=float, default=1.0, help='Delay between payments in seconds (default: 1.0)')
    parser.add_argument('--max-invoices', type=int, help='Maximum number of invoices to pay')
    parser.add_argument('--output-dir', default='payment_results', help='Output directory for result files (default: payment_results)')
    parser.add_argument('--test-only', action='store_true', help='Only test loading files, do not make payments')
    parser.add_argument('--store-id', type=str, help='BTCPay Server store ID')
    parser.add_argument('--base-url', type=str, help='BTCPay Server base URL')
    parser.add_argument('--api-key', type=str, help='BTCPay Server API key')
    
    args = parser.parse_args()
    
    # Load configuration file if provided
    if args.config:
        try:
            config = load_config(args.config)
            if not validate_config(config):
                print(f"❌ Configuration validation failed")
                return 1
            args = merge_config_with_args(config, args)
            print(f"✅ Loaded configuration from: {args.config}")
        except Exception as e:
            print(f"❌ Error loading configuration: {str(e)}")
            return 1
    
    # Validate required arguments
    if not args.addresses:
        print("❌ Error: --addresses is required (or specify in config file)")
        return 1
    
    if not args.invoices:
        print("❌ Error: --invoices is required (or specify in config file)")
        return 1
    
    # Validate BTCPay Server configuration
    if not args.store_id:
        print("❌ Error: --store-id is required (or specify in config file)")
        return 1
    
    if not args.base_url:
        print("❌ Error: --base-url is required (or specify in config file)")
        return 1
    
    if not args.api_key:
        print("❌ Error: --api-key is required (or specify in config file)")
        return 1
    
    # Warning for mainnet usage
    if args.mainnet:
        print("\n⚠️  WARNING: You are about to make payments on Bitcoin MAINNET!")
        print("This will use real Bitcoin. Make sure this is intended.")
        response = input("Continue? (yes/no): ").lower().strip()
        if response != 'yes':
            print("Operation cancelled.")
            return 0
    
    try:
        # Initialize payment processor
        network = 'bitcoin' if args.mainnet else 'testnet'
        processor = BTCPayInvoicePayment(
            network=network,
            store_id=args.store_id,
            base_url=args.base_url,
            api_key=args.api_key
        )
        
        # Load addresses and invoices
        print("Loading addresses...")
        if not processor.load_addresses(args.addresses):
            print("❌ Failed to load addresses")
            return 1
        
        print("Loading invoices...")
        if not processor.load_invoices(args.invoices):
            print("❌ Failed to load invoices")
            return 1
        
        print(f"✅ Loaded {len(processor.addresses)} addresses and {len(processor.invoices)} invoices")
        
        # Pay invoices
        print(f"\nStarting payment process...")
        processor.pay_all_invoices(
            delay=args.delay,
            max_invoices=args.max_invoices,
            test_only=args.test_only
        )
        
        # Export results
        processor.export_results(args.output_dir)
        
        if processor.stats['successful_payments'] > 0:
            print(f"\n✅ Successfully paid {processor.stats['successful_payments']:,} invoices!")
        
        if processor.stats['failed_payments'] > 0:
            print(f"⚠️  {processor.stats['failed_payments']:,} payments failed.")
            print("Check the failed_payments_*.json file for details.")
        
        return 0 if processor.stats['failed_payments'] == 0 else 1
        
    except KeyboardInterrupt:
        print("\n\n⚠️  Payment process interrupted by user")
        if 'processor' in locals():
            processor.export_results(args.output_dir)
        return 1
    except Exception as e:
        print(f"\n❌ Unexpected error: {str(e)}")
        logger.error(f"Unexpected error: {str(e)}", exc_info=True)
        return 1


if __name__ == "__main__":
    exit(main())
